<?php

define("BASEDIR",__DIR__);

include BASEDIR.'/IMooc/Loader.php';
spl_autoload_register('\\IMooc\\Loader::autoload');



/*//配置与设计模式
1.PHP中使用ArrayAccess实现配置文件的加载
ArrayAccess 的作用是使得你的对象可以像数组一样可以被访问
2.在工厂方法中读取配置，生成可配置化的对象
3.使用装饰器模式实现权限验证，模板渲染，json串化
4.使用观察者模式实现数据更新事件的一系列更新操作
5.使用代理模式实现数据库的主从自动切换*/





//mvc结构
/*模型-视图-控制器，一种c/s或者b/s软件工程的组织方式
1.模型model:数据和存储的封装
2.视图view：展现层的封装，如web系统中的模板文件
3.控制器controller:逻辑层的封装*/




//面向对象编程的基本原则
/*1.单一职责：一个类，只需要做好一件事情
不要让一个类完成一个很复杂的功能，拆分更小更具体的类
2.开放封闭：一个类，应该可以扩展，而不可修改的
一个类实现后对扩展是开放的，但是对修改是封闭的，不应该是修改来增加功能，而是通过扩展来增加功能
3.依赖倒置：一个类，不应该强依赖另外一个类。每个类对于另外一个类都是可替换的。
比如说有两个类 a,b 如果a类需要依赖b类，实际上不应该在a类中直接调用b类，而是用依赖注入的方法，也就是说b可以替换的
4.配置化：尽可能的使用配置，而不是硬编码
比如数据参数，常量，还有类的关系定义
5.面向接口编程：只需要关心接口，不需要关心实现
所有的代码只需要关心某一个类提供哪些接口，不需要关心具体实现*/





//代理模式
//1.在客户端与实体之间建立一个代理对象（proxy），客户端对实体进行操作全部委派给代理对象，隐藏实体的具体实现细节
//2.有一个实例，从user表中读取信息，然后修改user表一个字段，那么在传统的编程中，业务系统需要知道是存储在那个数据库那个表中
//3.proxy还可以与业务代码分离，部署到另外的服务器。业务代码中通过RPC来委派任务
//传统的编程方式 (必须要手动选择主库和从库)
//$db = \IMooc\Factory::craeteDatabase('slave');
//$info = $db->query("select name from user where id = 1 limit 1");
//$db1 = \IMooc\Factory::craeteDatabase('master');
//$db1->query("update user name = 'lili' where id = 1 limit 1");
//$proxy = new \IMooc\Proxy();
//$proxy->getUserName($id);
//$proxy->setUserName($id,$proxy);








/*//迭代器模式
//1.迭代器模式，在不需要了解内部实现的前提下，遍历一个聚合对象的内部元素
//2.比如说我们有一个实例要提供一个alluser类，这个就表示user对象集合，可以遍历所有user对象
//3.相比于传统的编程模式，迭代器模式可以隐藏遍历元素的所需的操作
$users = new \IMooc\AllUser();
foreach ($users as $user)
{
    echo "<pre>";
    //var_dump($user);
    var_dump($user->name);
    $user->num = rand(1000,9999);
    echo "</pre>";
}*/






//装饰器模式
//1.装饰器模式，可以动态的添加修改类的功能
//2.一个类提供了一项功能，如果要在修改并添加额外的功能，传统的编程模式，需要写一个子类继承它，并重新实现类的方法
//3.使用装饰器模式，仅需要在运行时添加一个装饰器对象即可实现，可以实现最大的灵活性
//为画布增加颜色？怎么做
/*class Canvas2 extends IMooc\Canvas
{
    function draw()
    {
        echo "<div style='color:red;'>";
        parent::draw(); // TODO: Change the autogenerated stub
        echo "</div>";
    }
}
$canvas1 = new Canvas2();
$canvas1->init();
$canvas1->rect(3,6,4,12);
$canvas1->draw();*/
/*$canvas1 = new IMooc\Canvas();
$canvas1->init();
$canvas1->addDecorator(new \IMooc\ColorDrawDecorator('green'));
$canvas1->addDecorator(new \IMooc\SizeDrawDecorator('10px'));
$canvas1->rect(3,6,4,12);
$canvas1->draw();*/







/*//原型模式
//1.与工厂模式作用类似，都是用来创建对象
//2.与工厂模式的实现不同，原型模式是先创建好一个原型对象，然后通过clone原型对象来创建新的对象。这样免去了类创建时重复的初始化操作。
//3.原型模式使用于大对象的创建。创建一个大的对象需要很大的开销，如果每次new就会消耗很大，原型模式仅需内存拷贝即可
//$canvas1 = new IMooc\Canvas();
//$canvas1->init();
//$canvas1->rect(3,6,4,12);
//$canvas1->draw();

//echo "------------------------------";
//echo "<br/>";

//$canvas2 = new IMooc\Canvas();
//$canvas2->init();
//$canvas2->rect(1,3,2,6);
//$canvas2->draw();

$prototype = new IMooc\Canvas();
$prototype->init();
//------------------------------
$canvas1 = clone $prototype;
$canvas1->rect(3,6,4,12);
$canvas1->draw();

echo "------------------------------";
echo "<br/>";

$canvas2 = clone $prototype;
$canvas2->rect(1,3,2,6);
$canvas2->draw();*/






/*//观察者模式
//1.观察者模式，当一个对象状态发生改变时，依赖它的对象全部会收到通知，并且自动更新
//2.场景：一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理逻辑。当更新的逻辑增多之后，代码会变得难以维护。
//这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件主体代码。
//3.观察者模式实现了低耦合，非侵入式的通知与更行机制

class Event extends \IMooc\EventGenerator
{
    //触发一个新的事件
    function trigger()
    {
        //echo "Event<br/>\n";
        //传统的编码方式是，在在事件编码之后就开始写更新逻辑
        //echo "update逻辑1<br/>";
        //echo "update逻辑2<br/>";
        //echo "update逻辑3<br/>";

        echo "Event<br/>\n";
        $this->notify();
    }
}

//编写观察者
class Observer1 implements \IMooc\Observer
{
    function update($event_info = null)
    {
        echo "逻辑1<br/>\n";
    }
}
class Observer2 implements \IMooc\Observer
{
    function update($event_info = null)
    {
        echo "逻辑2<br/>\n";
    }
}

$event = new Event();
//观察者加到监听列表中
$event->addObserver(new Observer1);
$event->addObserver(new Observer2);
$event->trigger();*/




/*//数据对象映射模式
//1.数据对象映射模式，是将对象和数据存储映射起来，对一个对象的操作会映射为对数据存储的操作
//2.在代码中实现数据对象映射模式，我们将实现一个ORM类，将复杂的SQL语句映射成对象属性的操作
//3.结合使用数据对象映射模式，工厂模式，注册模式
//$user = new IMooc\User(1);
//var_dump($user->id,$user->mobile,$user->name,$user->regtime);
//die;
//$user->mobile = "15222222222";
//$user->name = 'test111';
//$user->regtime = date('Y-m-d H:i:s');

class Page
{
    function index()
    {
        //$user = new IMooc\User(1);
        $user = IMooc\Factory::getUser(1);
        $user->name = 'test115';
        $this->test4();
        echo "ok";
    }
    function test4()
    {
        //$user = new IMooc\User(1);
        $user = IMooc\Factory::getUser(1);
        $user->mobile = "15244444444";
    }
}
$page = new page();
$page->index();*/





/*//策略模式
//1.策略模式，将一组特定的行为和算法封装成类，以适应某些特定的上线文环境，这种模式就是策略模式
//2.实际应用的例子，假如一个电商网站系统，针对男性女性用户要各自跳转到不同的商品类目，并且所有的广告位展示不同的广告
//3.使用策略模式可以实现IOC,依赖倒置，控制反转


class Page
{
    protected $strategy;
    function index()
    {
        echo "AD:";
        $this->strategy->showAd();
        echo "<br/>";
        echo "Category:";
        $this->strategy->showCategory();
        //传统编程方法是,硬编码
        //if(isset($_GET['female']))
        //{
        //
        //}
        //else
        //{
        //
        //}
    }

    //约定接口参数类型
    function setStrategy(\IMooc\UserStrategy $strategy)
    {
        $this->strategy = $strategy;
    }
}
$page = new Page();
if(isset($_GET['female'])){
    $strategy = new \IMooc\FemaleUserStrategy();
}else{
    $strategy = new \IMooc\MaleUserStrategy();
}
$page->setStrategy($strategy);
$page->index();*/


//适配器模式
/*//1.适配器模式，可以将截然不同的函数接口封装成统一的API
//2.实际应用举例，PHP的数据库操作有mysql，mysqli,pdo3种，可以用适配器模式统一成一致。
//类似的场景还有cache适配器，将memcache，redis,apc等不同的缓存函数，统一成一致。
//$db = new IMooc\Database\MySQL();
//$db = new IMooc\Database\MySQLi();
$db = new IMooc\Database\PDO();
$db->connect('127.0.0.1','root','root','test');
$res = $db->query("show databases");
$db->close();
var_dump($res);*/


//3中基础设计模式
/*//1.工厂模式  工厂方法或者类生成对象，而不是在代码中直接new一个对象
//旧模式
//$db = new IMooc\Database();
$db = IMooc\Factory::craeteDatabase();
//工厂模式为什么会比直接new一个对象要好呢？？
//假如Database类在很多地方使用了，如果Database参数发生了变化，工厂模式只需要改一次就可以使用了

//2.单例模式   使某个类的对象只容许创建一个
//$db = IMooc\Database::getInstance();

//3.注册模式   解决全局共享和交换对象
$db2 = IMooc\Register::get("db1");
var_dump($db2);*/


//php魔术方法使用
/*$obj = new IMooc\Objects();
//$obj->title = "hello";
//echo $obj->title;

//$obj->test1("hello",123);
//IMooc\Objects::test2("hello1","12345");

//echo $obj;
echo $obj("test3");*/



//php链式操作核心，每个函数 返回$this
/*$db = new \IMooc\Database();
//简化开发
$db->where("id=1")->where("name=2")->limit(10)->order("id desc");
//$db->where("id=1");
//$db->where("name=2");
//$db->order("id desc");
//$db->limit("10");*/

//psr-0基础框架
//IMooc\Objects::test();
//App\Controller\Home\Index::test();

//spl标准库
/*//栈数据结构 后进先出
$stack = new SplStack();
$stack->push("data1"); //入栈
$stack->push("data2");

//echo $stack->pop();   //出栈
//echo $stack->pop();

//队列数据结构  先进先出
$queue = new SplQueue();
$queue->enqueue('data1');  //入队列
$queue->enqueue('data2');

//echo $queue->dequeue(); //出队列
//echo $queue->dequeue();

//堆数据结构
$heap = new SplMinHeap();
$heap->insert('data1');
$heap->insert('data2');

//echo $heap->extract();
//echo $heap->extract();

//固定长度数组
$array = new SplFixedArray(10);
$array[0] = 123;
$array[9] = 1234;

//var_dump($array);*/
